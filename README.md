1)Алгоритмы сортировки
Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.
2
Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).
2. Каждый элемент помещается в корзину согласно функции распределения.
3. Содержимое каждой корзины сортируется индивидуально.
4. Корзины соединяются в порядке увеличения диапазона.
Особенности:
Эффективна для равномерно распределённых числовых данных и может достигать линейной
асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает
при неравномерном распределении данных.

def insertion_sort(arr):
    """Сортировка вставками для сортировки элементов в корзинах."""
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # Перемещаем элементы arr[0..i-1], которые больше ключа, на одну позицию вперед
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def bucket_sort(arr):
    """Основная функция блочной сортировки."""
    if len(arr) == 0:
        return arr

    # 1. Определяем количество корзин
    num_buckets = 10  # Количество корзин
    max_value = max(arr)
    min_value = min(arr)
    bucket_range = (max_value - min_value) / num_buckets

    # 2. Создаем корзины
    buckets = [[] for _ in range(num_buckets)]

    # 3. Распределяем элементы по корзинам
    for num in arr:
        index = int((num - min_value) // bucket_range)
        if index == num_buckets:  # Обработка крайних значений
            index -= 1
        buckets[index].append(num)

    # 4. Сортируем каждую корзину и объединяем их
    sorted_array = []
    for bucket in buckets:
        insertion_sort(bucket)  # Сортируем каждую корзину с помощью сортировки вставками
        sorted_array.extend(bucket)  # Объединяем отсортированные корзины

    return sorted_array


Исходный массив: [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.55, 0.63, 0.87]

Параметры:

Количество корзин: 10
Минимальное значение: 0,17
Максимальное значение: 0,94
Диапазон корзины: (0,94 — 0,17) / 10 = 0,077
Распределение по корзинам:

Корзина 0: [0,17, 0,21]
Корзина 1: [0,26]
Корзина 2: [0,39]
Корзина 3: []
Корзина 4: [0,55]
Корзина 5: [0,63]
Корзина 6: []
Корзина 7: [0,78, 0,72]
Корзина 8: [0,87]
Корзина 9: [0,94]
После сортировки каждой корзины:

Корзина 7 стала: [0,72, 0,78] (была [0,78, 0,72])
Финальный результат: [0.17, 0.21, 0.26, 0.39, 0.55, 0.63, 0.72, 0.78, 0.87, 0.94]
 
Временная сложность алгоритма блочной сортировки

Временная сложность алгоритма блочной сортировки можно оценить как O(n + k), где:
• n — количество элементов в исходном массиве.
• k — количество корзин.

Объяснение оценки:

1. Распределение элементов по корзинам:
   – Для каждого элемента из массива мы определяем, в какую корзину его поместить. Это занимает O(n) времени, так как мы проходим по всем элементам массива.

2. Сортировка каждой корзины:
   – В худшем случае каждая корзина может содержать все элементы из исходного массива (например, если все элементы имеют одинаковое значение). Однако, если данные равномерно распределены, то в среднем количество элементов в каждой корзине будет равно n/k.
   – Сортировка вставками имеет временную сложность O(m²), где m — количество элементов в корзине. Если мы сортируем каждую корзину, это займет O((n/k)²) для каждой из k корзин. Однако, учитывая, что k корзин, общее время на сортировку всех корзин будет O(k * (n/k)²) = O(n²/k).

3. Объединение отсортированных элементов:
   – Объединение всех отсортированных корзин в один массив также занимает O(n) времени.

Итоговая оценка:

Таким образом, при равномерном распределении данных, когда количество корзин k увеличивается, временная сложность алгоритма блочной сортировки стремится к O(n). В худшем случае (когда все элементы попадают в одну корзину) сложность может достигать O(n²), но это маловероятно при адекватном выборе количества корзин и распределении входных данных.

Поэтому в большинстве случаев можно считать, что временная сложность блочной сортировки составляет O(n + k), что делает ее эффективной для больших объемов данных при условии, что данные распределены равномерно.



2)Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым.
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
4. Повторить процесс для оставшейся неотсортированной части массива.
Особенности:
Сложность алгоритма — O(n2). Он интересен теоретически и используется как пример
нестандартных методов сортировки.


def flip(arr, k):
    """
    Функция для переворота подмассива до индекса k.
    arr: список, который нужно перевернуть.
    k: индекс до которого нужно перевернуть (включительно).
    """
    start = 0  # Начинаем с начала массива
    while start < k:  # Пока стартовый индекс меньше k
        arr[start], arr[k] = arr[k], arr[start]  # Меняем местами элементы
        start += 1  # Увеличиваем стартовый индекс
        k -= 1  # Уменьшаем конечный индекс

def find_max_index(arr, n):
    """
    Функция для поиска индекса максимального элемента в массиве.
    arr: список, в котором ищем максимальный элемент.
    n: количество элементов в массиве.
    Возвращает индекс максимального элемента.
    """
    max_index = 0  # Предполагаем, что первый элемент максимален
    for i in range(1, n):  # Проходим по всем элементам массива
        if arr[i] > arr[max_index]:  # Если текущий элемент больше максимального
            max_index = i  # Обновляем индекс максимального элемента
    return max_index  # Возвращаем индекс максимального элемента

def pancake_sort(arr):
    """
    Функция для сортировки массива с помощью блинной сортировки.
    arr: список, который нужно отсортировать.
    """
    n = len(arr)  # Получаем длину массива
    for curr_size in range(n, 1, -1):  # Проходим по массиву от конца к началу
        max_index = find_max_index(arr, curr_size)  # Находим индекс максимального элемента
        if max_index != curr_size - 1:  # Если максимальный элемент не на своем месте
            if max_index != 0:  # Если максимальный элемент не первый
                flip(arr, max_index)  # Переворачиваем подмассив до max_index
            flip(arr, curr_size - 1)  # Переворачиваем весь подмассив до curr_size - 1

# Пример использования:
arr = [3, 6, 1, 5, 2, 4]
print("Исходный массив:", arr)
pancake_sort(arr)  # Сортируем массив
print("Отсортированный массив:", arr)

Исходный массив: [3, 6, 1, 5, 2, 4]
Начинаем сортировку массива: [3, 6, 1, 5, 2, 4]

Работа с подмассивом размера 6: [3, 6, 1, 5, 2, 4]
Максимальный элемент 6 найден на позиции 1
Переворачиваем массив до индекса 1: [3, 6]
После переворота: [6, 3, 1, 5, 2, 4]
Переворачиваем массив до индекса 5: [6, 3, 1, 5, 2, 4]
После переворота: [4, 2, 5, 1, 3, 6]

Работа с подмассивом размера 5: [4, 2, 5, 1, 3]
Максимальный элемент 5 найден на позиции 2
Переворачиваем массив до индекса 2: [4, 2, 5]
После переворота: [5, 2, 4, 1, 3, 6]
Переворачиваем массив до индекса 4: [5, 2, 4, 1, 3]
После переворота: [3, 1, 4, 2, 5, 6]

Работа с подмассивом размера 4: [3, 1, 4, 2]
Максимальный элемент 4 найден на позиции 2
Переворачиваем массив до индекса 2: [3, 1, 4]
После переворота: [4, 1, 3, 2, 5, 6]
Переворачиваем массив до индекса 3: [4, 1, 3, 2]
После переворота: [2, 3, 1, 4, 5, 6]

Работа с подмассивом размера 3: [2, 3, 1]
Максимальный элемент 3 найден на позиции 1
Переворачиваем массив до индекса 1: [2, 3]
После переворота: [3, 2, 1, 4, 5, 6]
Переворачиваем массив до индекса 2: [3, 2, 1]
После переворота: [1, 2, 3, 4, 5, 6]

Работа с подмассивом размера 2: [1, 2]
Максимальный элемент 2 найден на позиции 1
Максимальный элемент уже на правильной позиции

Отсортированный массив: [1, 2, 3, 4, 5, 6]
Оценка временной сложности алгоритма блинной сортировки

Временная сложность: O(n²)

▎Краткое объяснение:

1. Поиск максимального элемента:
   – В функции find_max_index, мы проходим по массиву длиной n для поиска максимального элемента. Это требует O(n) времени.

2. Переворот подмассива:
   – В функции flip, мы также проходим по массиву, чтобы перевернуть элементы до индекса k. В худшем случае, этот процесс может занять O(n) времени.

3. Основной цикл:
   – В функции pancake_sort, основной цикл выполняется n-1 раз (от n до 2). На каждой итерации мы сначала ищем максимальный элемент (время O(n)), а затем выполняем один или два переворота (время также O(n)).
   – Таким образом, для каждой итерации основного цикла мы тратим O(n) + O(n) = O(n).

4. Общая временная сложность:
   – Поскольку основной цикл выполняется n-1 раз и на каждой итерации требуется O(n) времени, общая временная сложность алгоритма будет:

O(n) × O(n) = O(n²)

Таким образом, блинная сортировка имеет временную сложность O(n²), что делает ее менее эффективной по сравнению с другими алгоритмами сортировки, такими как быстрая сортировка или сортировка слиянием, которые имеют временную сложность O(n log n) в среднем случае.



3)Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.
Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
2. Бусины располагаются на «стержнях» (как на абаке).
3. Под действием «гравитации» бусины падают вниз.
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
Особенности:
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.


def bead_sort(arr):
    # Проверяем, пустой ли массив
    if not arr:
        return arr  # Если массив пустой, возвращаем его как есть

    # Находим максимальное значение в массиве
    max_value = max(arr)
    
    # Создаем матрицу, где строки соответствуют элементам массива, а столбцы - максимальному значению
    beads = [[0] * len(arr) for _ in range(max_value)]
    
    # Заполняем матрицу бусинами
    for i in range(len(arr)):
        for j in range(arr[i]):
            beads[j][i] = 1  # Устанавливаем 1 для каждой бусины на позиции i и высоте j

    # Теперь мы будем "падать" бусинам вниз
    # Создаем новый массив для хранения отсортированных значений
    sorted_arr = [0] * len(arr)

    # Для каждого столбца (каждого элемента исходного массива)
    for i in range(len(arr)):
        # Считаем, сколько бусин "упало" вниз
        count = 0
        for j in range(max_value):
            count += beads[j][i]  # Суммируем количество бусин в столбце i
            
        # Записываем количество бусин в отсортированный массив
        sorted_arr[i] = count  # Количество бусин соответствует значению в отсортированном массиве

    return sorted_arr  # Возвращаем отсортированный массив

# Пример использования функции
input_array = [5, 3, 1, 4, 2]
sorted_array = bead_sort(input_array)
print(sorted_array)  # Вывод: [1, 2, 3, 4, 5]

Оценка временной сложности алгоритма Bead Sort
Временная сложность: O(S), где S = n × m:

n - количество элементов в массиве

m - максимальное значение в массиве

Краткое объяснение:
Построение матрицы бусин: O(n × m)

Внешний цикл по всем элементам массива (n итераций)

Внутренний цикл по значению каждого элемента (до m итераций)

"Падение" бусин и подсчет: O(n × m)

Внешний цикл по всем элементам (n итераций)

Внутренний цикл по высоте матрицы (m итераций)
Пространственная сложность: O(n × m) для хранения матрицы бусин

Алгоритм эффективен только когда значения в массиве относительно малы по сравнению с количеством элементов. При больших значениях m сложность становится неприемлемой.

4)Алгоритмы поиска
Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.
Принцип работы:
1. Делится массив на блоки длины m=n.
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.
Особенности:
В среднем сложность поиска O(n).
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное
время.

import math

def jump_search(arr, target):
    """
    Алгоритм поиска скачками (Jump Search)
    
    Args:
        arr: отсортированный список элементов
        target: искомый элемент
    
    Returns:
        int: индекс элемента или -1 если не найден
    """
    n = len(arr)
    
    # Если массив пустой
    if n == 0:
        return -1
    
    # Определяем размер прыжка (оптимально √n)
    jump_size = int(math.sqrt(n))
    
    # Находим блок, где может находиться элемент
    prev = 0
    step = jump_size
    
    # Прыгаем вперед, пока не найдем блок с элементом >= target
    while step < n and arr[min(step, n-1)] < target:
        prev = step
        step += jump_size
        
        # Если вышли за границы массива
        if prev >= n:
            return -1
    
    # Линейный поиск в найденном блоке
    for i in range(prev, min(step, n)):
        if arr[i] == target:
            return i
    
    return -1

def jump_search_with_steps(arr, target):
    """
    Версия с выводом шагов для демонстрации работы алгоритма
    """
    n = len(arr)
    
    if n == 0:
        print("Массив пустой")
        return -1
    
    jump_size = int(math.sqrt(n))
    print(f"Размер массива: {n}")
    print(f"Размер прыжка: {jump_size}")
    print(f"Ищем элемент: {target}")
    print()
    
    prev = 0
    step = jump_size
    
    print("Фаза прыжков:")
    step_count = 0
    
    while step < n and arr[min(step, n-1)] < target:
        print(f"Шаг {step_count + 1}: проверяем индекс {min(step, n-1)} = {arr[min(step, n-1)]}")
        prev = step
        step += jump_size
        step_count += 1
        
        if prev >= n:
            print("Вышли за границы массива")
            return -1
    
    print(f"Найден блок: индексы от {prev} до {min(step, n-1)}")
    print()
    
    print("Фаза линейного поиска в блоке:")
    for i in range(prev, min(step, n)):
        print(f"Проверяем индекс {i}: {arr[i]}")
        if arr[i] == target:
            print(f"Элемент найден на позиции {i}")
            return i
    
    print("Элемент не найден")
    return -1
if __name__ == "__main__":
    # Пример 1: простой случай
    print("=== Пример 1 ===")
    arr1 = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
    target1 = 55
    
    result1 = jump_search_with_steps(arr1, target1)
    print(f"Результат: {result1}")
    print()

=== Пример 1 ===
Размер массива: 13
Размер прыжка: 3
Ищем элемент: 55

Фаза прыжков:
Шаг 1: проверяем индекс 3 = 2
Шаг 2: проверяем индекс 6 = 8
Шаг 3: проверяем индекс 9 = 34
Найден блок: индексы от 9 до 12

Фаза линейного поиска в блоке:
Проверяем индекс 9: 34
Проверяем индекс 10: 55
Элемент найден на позиции 10
Результат: 10

В среднем сложность поиска O(n).

Количество прыжков: O(n/m)

Линейный поиск в блоке: O(m)

Но если элемент в конце или отсутствует, линейный поиск проверяет O(n) элементов



5)Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.
Принцип работы:
1. Проверяется первый элемент массива.
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
3. На найденном диапазоне выполняется бинарный поиск.
Особенности:
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.

def exponential_search(arr, target):
    """
    Алгоритм экспоненциального поиска (Exponential Search)
    
    Args:
        arr: отсортированный список элементов
        target: искомый элемент
    
    Returns:
        int: индекс элемента или -1 если не найден
    """
    n = len(arr)
    
    # Если массив пустой
    if n == 0:
        return -1
    
    # Если первый элемент - искомый
    if arr[0] == target:
        return 0
    
    # Находим диапазон для бинарного поиска экспоненциальным увеличением границы
    bound = 1
    while bound < n and arr[bound] <= target:
        bound *= 2
    
    # Выполняем бинарный поиск в найденном диапазоне
    left = bound // 2
    right = min(bound, n - 1)
    
    return binary_search(arr, target, left, right)

def binary_search(arr, target, left, right):
    """
    Вспомогательная функция бинарного поиска в заданном диапазоне
    """
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

def exponential_search_with_steps(arr, target):
    """
    Версия с выводом шагов для демонстрации работы алгоритма
    """
    n = len(arr)
    
    if n == 0:
        print("Массив пустой")
        return -1
    
    print(f"Массив: {arr}")
    print(f"Ищем элемент: {target}")
    print()
    
    # Проверяем первый элемент
    print("1. Проверяем первый элемент:")
    print(f"   arr[0] = {arr[0]}")
    if arr[0] == target:
        print(f"   Элемент найден на позиции 0")
        return 0
    print("   Первый элемент не равен целевому, продолжаем...")
    print()
    
    # Экспоненциально увеличиваем границу
    print("2. Фаза экспоненциального увеличения границы:")
    bound = 1
    step = 1
    
    while bound < n and arr[bound] <= target:
        print(f"   Шаг {step}: bound = {bound}, arr[{bound}] = {arr[bound]}")
        bound *= 2
        step += 1
    
    # Определяем границы для бинарного поиска
    left = bound // 2
    right = min(bound, n - 1)
    
    print(f"   Найден диапазон для бинарного поиска: от {left} до {right}")
    print(f"   Элементы в диапазоне: {arr[left:right+1]}")
    print()
    
    # Выполняем бинарный поиск
    print("3. Фаза бинарного поиска:")
    result = binary_search_with_steps(arr, target, left, right)
    
    return result

def binary_search_with_steps(arr, target, left, right):
    """
    Вспомогательная функция бинарного поиска с выводом шагов
    """
    step = 1
    
    while left <= right:
        mid = left + (right - left) // 2
        print(f"   Шаг {step}: left={left}, right={right}, mid={mid}, arr[{mid}]={arr[mid]}")
        
        if arr[mid] == target:
            print(f"   Элемент найден на позиции {mid}")
            return mid
        elif arr[mid] < target:
            print(f"   arr[{mid}] < {target}, ищем в правой половине")
            left = mid + 1
        else:
            print(f"   arr[{mid}] > {target}, ищем в левой половине")
            right = mid - 1
        
        step += 1
    
    print("   Элемент не найден в диапазоне")
    return -1

# Демонстрация работы алгоритма
if __name__ == "__main__":
    print("=== Экспоненциальный поиск (Exponential Search) ===\n")
    
    # Пример 1: простой случай
    print("=== Пример 1 ===")
    arr1 = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]
    target1 = 17
    
    result1 = exponential_search_with_steps(arr1, target1)
    print(f"Результат: {result1}")
    print()

=== Пример 1 ===
Массив: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29]
Ищем элемент: 17

1. Проверяем первый элемент:
   arr[0] = 1
   Первый элемент не равен целевому, продолжаем...

2. Фаза экспоненциального увеличения границы:
   Шаг 1: bound = 1, arr[1] = 3
   Шаг 2: bound = 2, arr[2] = 5
   Шаг 3: bound = 4, arr[4] = 9
   Шаг 4: bound = 8, arr[8] = 17
   Найден диапазон для бинарного поиска: от 8 до 14
   Элементы в диапазоне: [17, 19, 21, 23, 25, 27, 29]

3. Фаза бинарного поиска:
   Шаг 1: left=8, right=14, mid=11, arr[11]=23
   arr[11] > 17, ищем в левой половине
   Шаг 2: left=8, right=10, mid=9, arr[9]=19
   arr[9] > 17, ищем в левой половине
   Шаг 3: left=8, right=8, mid=8, arr[8]=17
   Элемент найден на позиции 8
Результат: 8


Оценка временной сложности алгоритма Exponential Search
Временная сложность: O(log i), где i - позиция искомого элемента

Краткое объяснение:
Алгоритм состоит из двух фаз:

python
def exponential_search(arr, target):
    # Фаза 1: Экспоненциальное увеличение границы - O(log i)
    bound = 1
    while bound < n and arr[bound] <= target:
        bound *= 2  # Удваиваем границу на каждом шаге
    
    # Фаза 2: Бинарный поиск - O(log i)
    left = bound // 2
    right = min(bound, n - 1)
    return binary_search(arr, target, left, right)
Детальный анализ:
Фаза экспоненциального увеличения: O(log i)

Граница увеличивается: 1 → 2 → 4 → 8 → ... → i

Количество шагов: log₂i

Фаза бинарного поиска: O(log i)

Размер диапазона: от i/2 до i (или меньше)

Количество сравнений: log₂(i/2) = log₂i - 1

Общая сложность: O(log i) + O(log i) = O(log i)
